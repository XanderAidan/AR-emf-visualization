<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Aether Scanner: Heatmap</title>
    <style>
        :root {
            --hud-bg: rgba(10, 10, 16, 0.85);
            --neon-blue: #00f3ff;
            --neon-green: #00ff9d;
            --neon-red: #ff0055;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', monospace;
            background-color: #000;
            color: #fff;
            user-select: none;
        }

        /* --- HUD LAYOUT --- */
        #hud {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: none;
            z-index: 10;
        }

        .panel {
            position: absolute;
            background: var(--hud-bg);
            backdrop-filter: blur(4px);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .top-bar {
            top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px;
            white-space: nowrap;
        }

        .stat-box { text-align: center; }
        .label { font-size: 0.6rem; color: #888; letter-spacing: 1px; }
        .val { font-size: 1.1rem; font-weight: bold; font-family: 'Courier New', monospace; }

        .c-safe { color: var(--neon-blue); }
        .c-warn { color: #ffcc00; }
        .c-danger { color: var(--neon-red); }

        /* Color Scale Legend */
        .legend {
            position: absolute;
            bottom: 30px; right: 20px;
            width: 10px; height: 150px;
            background: linear-gradient(to top, var(--neon-blue), var(--neon-green), #ffcc00, var(--neon-red));
            border-radius: 5px;
            border: 1px solid rgba(255,255,255,0.3);
        }
        .legend::after {
            content: 'MAX'; position: absolute; top: -15px; left: -10px; font-size: 0.6rem;
        }
        .legend::before {
            content: 'MIN'; position: absolute; bottom: -15px; left: -10px; font-size: 0.6rem;
        }

        /* Intro Screen */
        #intro {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        button {
            background: transparent;
            color: var(--neon-blue);
            border: 2px solid var(--neon-blue);
            padding: 15px 30px;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <div id="intro">
        <h1 style="color: var(--neon-blue);">AETHER MAPPER</h1>
        <p style="color: #666; font-size: 0.8rem;">EMF & ULTRASOUND VISUALIZER</p>
        <button id="start-btn">INITIALIZE AR</button>
    </div>

    <div id="hud">
        <div class="panel top-bar">
            <div class="stat-box">
                <div class="label">EMF (µT)</div>
                <div id="val-mag" class="val c-safe">0.0</div>
            </div>
            <div class="stat-box">
                <div class="label">ULTRASOUND</div>
                <div id="val-ultra" class="val c-safe">LOW</div>
            </div>
        </div>
        <div class="legend"></div>
    </div>

    <!-- Three.js Imports -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // --- CONFIG ---
        const CONFIG = {
            spawnRate: 50,      // ms (Faster for smoother trail)
            particleLife: 15000, // Trail stays longer (15s)
            magMin: 30,         // Blue
            magMax: 100,        // Red
        };

        // --- STATE ---
        let camera, scene, renderer;
        let particles = [];
        let lastSpawn = 0;
        
        let sData = {
            mag: 40,
            ultrasound: 0 // 0.0 to 1.0
        };

        const textureLoader = new THREE.TextureLoader();
        // Create a soft glow texture programmatically
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,32,32);
        const glowTexture = new THREE.CanvasTexture(canvas);

        init();

        function init() {
            const btn = document.getElementById('start-btn');
            btn.addEventListener('click', () => {
                document.getElementById('intro').style.display = 'none';
                document.getElementById('hud').style.display = 'block';
                setupSensors();
                setupThree();
            });
        }

        async function setupSensors() {
            // 1. Magnetometer
            if ('Magnetometer' in window) {
                try {
                    const mag = new Magnetometer({ frequency: 60 });
                    mag.addEventListener('reading', () => {
                        sData.mag = Math.sqrt(mag.x**2 + mag.y**2 + mag.z**2);
                        updateHUD();
                    });
                    mag.start();
                } catch(e) { console.log("Mag error", e); }
            } else {
                // Sim mode
                setInterval(() => {
                    sData.mag = 40 + Math.sin(Date.now()/1000)*30; 
                    updateHUD();
                }, 100);
            }

            // 2. Ultrasound (High Frequency Audio)
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const analyser = audioCtx.createAnalyser();
                const source = audioCtx.createMediaStreamSource(stream);
                source.connect(analyser);
                analyser.fftSize = 64; // 32 bins
                const data = new Uint8Array(analyser.frequencyBinCount);

                const loop = () => {
                    analyser.getByteFrequencyData(data);
                    // Check top 25% of frequencies (approx 15kHz - 24kHz)
                    let sum = 0;
                    const startBin = Math.floor(data.length * 0.75);
                    for(let i=startBin; i<data.length; i++) sum += data[i];
                    
                    // Normalize (High freq is usually very quiet, so amplify)
                    sData.ultrasound = Math.min((sum / (data.length - startBin)) / 30.0, 1.0);
                    
                    requestAnimationFrame(loop);
                };
                loop();
            } catch(e) {}
        }

        function updateHUD() {
            const uiMag = document.getElementById('val-mag');
            uiMag.innerText = sData.mag.toFixed(1);
            
            // Color Logic
            if(sData.mag < 50) uiMag.className = "val c-safe";
            else if(sData.mag < 80) uiMag.className = "val c-warn";
            else uiMag.className = "val c-danger";

            const uiUltra = document.getElementById('val-ultra');
            if(sData.ultrasound > 0.5) {
                uiUltra.innerText = "DETECTED";
                uiUltra.className = "val c-danger";
            } else {
                uiUltra.innerText = "LOW";
                uiUltra.className = "val c-safe";
            }
        }

        function setupThree() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            const arBtn = ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test', 'dom-overlay'], 
                domOverlay: { root: document.body } 
            });
            document.body.appendChild(arBtn);

            renderer.setAnimationLoop(render);
        }

        // Reusable material for particles (using Additive Blending for "Heatmap" look)
        const particleMat = new THREE.PointsMaterial({
            size: 0.15, // 15cm dots
            map: glowTexture,
            transparent: true,
            opacity: 0.8,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        // Geometry buffer for particles
        const MAX_POINTS = 1000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(MAX_POINTS * 3);
        const colors = new Float32Array(MAX_POINTS * 3);
        const sizes = new Float32Array(MAX_POINTS); // For ultrasound jitter
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        // We will manually manage the "active" particles
        const particleSystem = new THREE.Points(geometry, particleMat);
        // Ensure standard frustum culling doesn't hide it if bounding box is old
        particleSystem.frustumCulled = false; 
        scene.add(particleSystem);

        let particleCount = 0;
        let pData = []; // Store metadata (birth time, etc)

        function render(timestamp, frame) {
            // Spawn Logic
            if ((renderer.xr.isPresenting || true) && (timestamp - lastSpawn > CONFIG.spawnRate)) {
                spawnParticle();
                lastSpawn = timestamp;
            }

            // Update Geometry
            const posAttr = geometry.attributes.position;
            const colAttr = geometry.attributes.color;

            // Shift Array or Ring Buffer? For simplicity, we just rebuild arrays or use a rolling index.
            // Let's standard array management for readability:
            
            // 1. Remove old particles
            for (let i = pData.length - 1; i >= 0; i--) {
                if (timestamp - pData[i].birth > CONFIG.particleLife) {
                    pData.splice(i, 1);
                }
            }

            // 2. Update Buffer Attributes
            for (let i = 0; i < pData.length; i++) {
                const p = pData[i];
                
                // Jitter effect if Ultrasound detected
                let jitterX = 0, jitterY = 0;
                if (p.ultra > 0.2) {
                    const amount = p.ultra * 0.02;
                    jitterX = (Math.random()-0.5) * amount;
                    jitterY = (Math.random()-0.5) * amount;
                }

                positions[i*3] = p.x + jitterX;
                positions[i*3+1] = p.y + jitterY;
                positions[i*3+2] = p.z;

                colors[i*3] = p.r;
                colors[i*3+1] = p.g;
                colors[i*3+2] = p.b;
            }

            geometry.setDrawRange(0, pData.length);
            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;

            renderer.render(scene, camera);
        }

        function spawnParticle() {
            if (pData.length >= MAX_POINTS) pData.shift(); // Remove oldest

            // Get Position
            const vec = new THREE.Vector3();
            if (renderer.xr.isPresenting) {
                const camPos = new THREE.Vector3(); 
                const camQuat = new THREE.Quaternion();
                camera.getWorldPosition(camPos);
                camera.getWorldQuaternion(camQuat);
                vec.copy(camPos).add(new THREE.Vector3(0, -0.2, -0.5).applyQuaternion(camQuat));
            } else {
                // Sim Orbit
                const t = Date.now() * 0.001;
                vec.set(Math.sin(t)*0.5, Math.cos(t)*0.2, Math.cos(t*0.5)*0.5);
            }

            // Calculate Color (Heatmap Gradient)
            // Normalized 0 to 1
            const t = Math.min(Math.max((sData.mag - CONFIG.magMin) / (CONFIG.magMax - CONFIG.magMin), 0), 1);
            
            // Heatmap: Blue -> Green -> Red
            const color = new THREE.Color();
            if (t < 0.5) {
                // Blue to Green
                color.lerpColors(new THREE.Color(0x00f3ff), new THREE.Color(0x00ff00), t * 2);
            } else {
                // Green to Red
                color.lerpColors(new THREE.Color(0x00ff00), new THREE.Color(0xff0000), (t - 0.5) * 2);
            }

            pData.push({
                x: vec.x, y: vec.y, z: vec.z,
                r: color.r, g: color.g, b: color.b,
                ultra: sData.ultrasound,
                birth: performance.now()
            });
        }
    </script>
</body>
</html>



        /* Sensor Capability Grid */
        .cap-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 30px;
            text-align: left;
            width: 100%;
            max-width: 300px;
        }

        .cap-item {
            display: flex;
            align-items: center;
            font-size: 0.8rem;
            color: #aaa;
        }

        .status-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            background: #333;
            margin-right: 10px;
            box-shadow: 0 0 5px #333;
            transition: 0.3s;
        }

        .ready { background: var(--neon-green); box-shadow: 0 0 8px var(--neon-green); }
        .sim { background: var(--neon-blue); box-shadow: 0 0 8px var(--neon-blue); }
        .error { background: var(--neon-red); }

        #start-btn {
            background: transparent;
            color: var(--neon-blue);
            border: 1px solid var(--neon-blue);
            padding: 15px 40px;
            font-size: 1rem;
            letter-spacing: 2px;
            cursor: pointer;
            text-transform: uppercase;
            transition: 0.2s;
        }
        #start-btn:active { background: rgba(0, 243, 255, 0.2); }

        /* --- HUD --- */
        #hud {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: none; /* Hidden until start */
            z-index: 60;
        }

        .hud-panel {
            position: absolute;
            background: var(--bg-dark);
            backdrop-filter: blur(5px);
            border: var(--hud-border);
            padding: 10px 15px;
            border-radius: 4px;
            pointer-events: auto;
        }

        .top-left { top: 20px; left: 20px; border-left: 3px solid var(--neon-blue); }
        .top-right { top: 20px; right: 20px; border-right: 3px solid var(--neon-red); text-align: right; }
        .bottom-center { 
            bottom: 30px; left: 50%; 
            transform: translateX(-50%); 
            display: flex; gap: 10px; 
            background: transparent; border: none; 
        }

        .data-label { font-size: 0.7rem; color: #888; display: block; margin-bottom: 2px; }
        .data-val { font-size: 1.2rem; font-weight: bold; font-family: monospace; }
        .c-blue { color: var(--neon-blue); }
        .c-red { color: var(--neon-red); }
        .c-gold { color: var(--neon-gold); }

        /* NFC Button */
        #nfc-btn {
            background: rgba(0,0,0,0.6);
            border: 1px solid var(--neon-gold);
            color: var(--neon-gold);
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
            text-transform: uppercase;
            font-size: 0.9rem;
        }
        #nfc-btn.scanning {
            background: var(--neon-gold);
            color: #000;
            box-shadow: 0 0 15px var(--neon-gold);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        #console-log {
            position: absolute;
            bottom: 80px; left: 20px;
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            max-width: 80%;
            pointer-events: none;
            text-shadow: 1px 1px 0 #000;
        }

    </style>
</head>
<body>

    <div class="scanlines"></div>

    <!-- INTRO -->
    <div id="intro-screen">
        <h1>Aether Scanner</h1>
        <div class="subtitle">Multi-Spectrum AR Visualization Tool<br>Pixel 10 Pro XL Optimized</div>

        <div class="cap-grid">
            <div class="cap-item"><div id="s-mag" class="status-dot"></div>Magnetometer</div>
            <div class="cap-item"><div id="s-mic" class="status-dot"></div>Microphone</div>
            <div class="cap-item"><div id="s-light" class="status-dot"></div>Light Sensor</div>
            <div class="cap-item"><div id="s-nfc" class="status-dot"></div>NFC Module</div>
        </div>

        <button id="start-btn">INITIALIZE SYSTEM</button>
        <div id="ar-warning" style="margin-top:20px; font-size: 0.7rem; color:#666; display:none;">
            Note: AR features require WebXR compatible browser.
        </div>
    </div>

    <!-- HUD -->
    <div id="hud">
        <!-- Top Left: EMF & Light -->
        <div class="hud-panel top-left">
            <div style="margin-bottom: 10px;">
                <span class="data-label">MAGNETIC FLUX</span>
                <span id="val-mag" class="data-val c-blue">0 µT</span>
            </div>
            <div>
                <span class="data-label">PHOTON DENSITY</span>
                <span id="val-light" class="data-val c-blue">0 Lx</span>
            </div>
        </div>

        <!-- Top Right: Audio -->
        <div class="hud-panel top-right">
            <span class="data-label">AUDIO GAIN</span>
            <span id="val-audio" class="data-val c-red">0 dB</span>
        </div>

        <!-- Bottom: Actions -->
        <div class="hud-panel bottom-center">
            <button id="nfc-btn">ARM NFC SCANNER</button>
        </div>

        <!-- Debug Log -->
        <div id="console-log">System Standby...</div>
    </div>

    <!-- THREE.JS IMPORT MAP -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // --- CONFIGURATION ---
        const CONFIG = {
            spawnInterval: 100,     // ms between cloud puffs
            particleLife: 8000,     // ms before puff dies
            simMode: false          // Fallback if no sensors
        };

        // --- STATE ---
        let camera, scene, renderer;
        let particles = [];
        let beacons = [];
        let lastSpawn = 0;
        let isNfcScanning = false;

        // Sensor Values
        let sData = {
            mag: 45,        // µT (Color)
            audio: 0,       // 0-1 (Size)
            light: 200      // Lux (Opacity)
        };

        // UI References
        const ui = {
            intro: document.getElementById('intro-screen'),
            hud: document.getElementById('hud'),
            valMag: document.getElementById('val-mag'),
            valAudio: document.getElementById('val-audio'),
            valLight: document.getElementById('val-light'),
            log: document.getElementById('console-log'),
            nfcBtn: document.getElementById('nfc-btn'),
            sDots: {
                mag: document.getElementById('s-mag'),
                mic: document.getElementById('s-mic'),
                light: document.getElementById('s-light'),
                nfc: document.getElementById('s-nfc')
            }
        };

        // --- INITIALIZATION ---
        initApp();

        function initApp() {
            // Pre-check sensors
            checkSensors();

            document.getElementById('start-btn').addEventListener('click', () => {
                ui.intro.style.display = 'none';
                ui.hud.style.display = 'block';
                initThree();
                activateSensors();
            });

            ui.nfcBtn.addEventListener('click', toggleNFC);
        }

        function log(msg) {
            ui.log.innerText = "> " + msg;
            console.log(msg);
        }

        // --- SENSOR HANDLING ---
        function checkSensors() {
            if ('Magnetometer' in window) ui.sDots.mag.classList.add('ready');
            else ui.sDots.mag.classList.add('sim');

            if ('AmbientLightSensor' in window) ui.sDots.light.classList.add('ready');
            else ui.sDots.light.classList.add('sim');

            if ('NDEFReader' in window) ui.sDots.nfc.classList.add('ready');
            else ui.sDots.nfc.classList.add('error');
            
            // Mic always "ready" until permission denied
            ui.sDots.mic.classList.add('ready');
        }

        async function activateSensors() {
            // 1. Audio (Requires user gesture, which click provided)
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const analyser = audioCtx.createAnalyser();
                const source = audioCtx.createMediaStreamSource(stream);
                source.connect(analyser);
                analyser.fftSize = 64;
                const dataArr = new Uint8Array(analyser.frequencyBinCount);

                const updateAudio = () => {
                    analyser.getByteFrequencyData(dataArr);
                    let sum = 0;
                    for(let i=0; i<dataArr.length; i++) sum += dataArr[i];
                    sData.audio = (sum / dataArr.length) / 255.0; // Norm 0-1
                    requestAnimationFrame(updateAudio);
                };
                updateAudio();
                log("Audio Uplink Active");
            } catch (e) {
                log("Audio Access Denied - Simulating");
                setInterval(() => { sData.audio = Math.random() * 0.3; }, 200);
            }

            // 2. Magnetometer
            if ('Magnetometer' in window) {
                try {
                    const mag = new Magnetometer({ frequency: 20 });
                    mag.addEventListener('reading', () => {
                        sData.mag = Math.sqrt(mag.x**2 + mag.y**2 + mag.z**2);
                    });
                    mag.start();
                } catch(e) { log("Mag Error: " + e); }
            } else {
                setInterval(() => { sData.mag = 40 + Math.sin(Date.now()/1000)*10; }, 100);
            }

            // 3. Light Sensor
            if ('AmbientLightSensor' in window) {
                try {
                    const light = new AmbientLightSensor({ frequency: 10 });
                    light.addEventListener('reading', () => { sData.light = light.illuminance; });
                    light.start();
                } catch(e) {}
            }
        }

        async function toggleNFC() {
            if (!('NDEFReader' in window)) {
                log("NFC Hardware Not Found");
                return;
            }

            if (isNfcScanning) {
                // Cannot easily stop NDEFReader without abort controller, but for UI:
                ui.nfcBtn.classList.remove('scanning');
                ui.nfcBtn.innerText = "ARM NFC SCANNER";
                isNfcScanning = false;
                log("NFC Disarmed");
            } else {
                try {
                    const ndef = new NDEFReader();
                    await ndef.scan();
                    ui.nfcBtn.classList.add('scanning');
                    ui.nfcBtn.innerText = "SCANNING...";
                    isNfcScanning = true;
                    log("Scan tag now...");

                    ndef.addEventListener("reading", () => {
                        log("NFC TAG DETECTED!");
                        spawnNfcBeacon();
                    });
                } catch (error) {
                    log("NFC Error: " + error);
                }
            }
        }

        // --- 3D SCENE & AR ---
        function initThree() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // Add standard WebXR button, but hide it visually since we use our own flow
            // Actually, we need the button to enter immersive-ar.
            const arBtn = ARButton.createButton(renderer, { requiredFeatures: ['hit-test', 'dom-overlay'], domOverlay: { root: document.body } });
            arBtn.style.position = 'absolute';
            arBtn.style.bottom = '100px'; 
            arBtn.style.opacity = '0'; // Hidden trigger
            arBtn.style.pointerEvents = 'none';
            document.body.appendChild(arBtn);
            
            // Auto-click AR button if available for seamless entry? 
            // Better to let Three.js handle it, but we can style the button generated by Three.js
            // The logic below restyles the button to match our theme
            arBtn.innerText = "ENTER AR MODE";
            arBtn.style.opacity = '1';
            arBtn.style.pointerEvents = 'auto';
            arBtn.style.background = 'rgba(0,0,0,0.8)';
            arBtn.style.border = '1px solid var(--neon-blue)';
            arBtn.style.color = 'var(--neon-blue)';
            arBtn.style.bottom = '150px'; // Move up above logs
            
            renderer.setAnimationLoop(render);
            
            // Resize handler
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // Reusable Geometries
        const cloudGeo = new THREE.IcosahedronGeometry(0.03, 1); // Base cloud particle
        const beaconGeo = new THREE.OctahedronGeometry(0.05, 0); // NFC Beacon

        function render(timestamp, frame) {
            updateHUD();

            // Only spawn if in AR (or strict sim mode)
            if (renderer.xr.isPresenting || CONFIG.simMode) {
                if (timestamp - lastSpawn > CONFIG.spawnInterval) {
                    spawnCloud();
                    lastSpawn = timestamp;
                }
            }

            // Animate Particles
            const time = timestamp * 0.001;
            
            // Clouds
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                let age = timestamp - p.userData.birth;
                if (age > CONFIG.particleLife) {
                    scene.remove(p);
                    p.material.dispose();
                    particles.splice(i, 1);
                } else {
                    p.material.opacity = p.userData.baseOp * (1 - (age / CONFIG.particleLife));
                    p.rotation.x = time + p.userData.offset;
                    p.rotation.y = time * 0.5;
                }
            }

            // Beacons (NFC)
            beacons.forEach(b => {
                b.rotation.y += 0.05;
                b.rotation.x += 0.02;
                b.scale.setScalar(1 + Math.sin(time * 5) * 0.2); // Pulse
            });

            renderer.render(scene, camera);
        }

        function updateHUD() {
            ui.valMag.innerText = sData.mag.toFixed(1) + " µT";
            ui.valAudio.innerText = Math.round(sData.audio * 100) + " %";
            ui.valLight.innerText = Math.round(sData.light) + " Lx";

            // Dynamic Styling
            ui.valMag.style.color = sData.mag > 60 ? 'var(--neon-red)' : 'var(--neon-blue)';
        }

        function spawnCloud() {
            const pos = getSpawnPosition();
            
            // Visuals Logic
            // Color = Magnetometer (Blue->Red)
            const magNorm = Math.min(Math.max((sData.mag - 30)/100, 0), 1);
            const color = new THREE.Color().lerpColors(new THREE.Color(0x00f3ff), new THREE.Color(0xff0055), magNorm);

            // Size = Audio
            const size = 1.0 + (sData.audio * 4.0);

            // Opacity = Light (Darker room = Fainter ghost, Bright room = Solid)
            // Or inverse? Let's make bright light = more transparent "ether"
            const opacity = Math.min(Math.max(sData.light / 500, 0.3), 0.9);

            const mat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: opacity,
                wireframe: true
            });

            const mesh = new THREE.Mesh(cloudGeo, mat);
            mesh.position.copy(pos);
            mesh.scale.set(size, size, size);
            mesh.userData = { birth: performance.now(), baseOp: opacity, offset: Math.random() };

            scene.add(mesh);
            particles.push(mesh);
        }

        function spawnNfcBeacon() {
            // Spawn a permanent gold marker at current location
            const pos = getSpawnPosition();
            const mat = new THREE.MeshBasicMaterial({ color: 0xffcc00, wireframe: true });
            const beacon = new THREE.Mesh(beaconGeo, mat);
            beacon.position.copy(pos);
            scene.add(beacon);
            beacons.push(beacon);
        }

        function getSpawnPosition() {
            const vec = new THREE.Vector3();
            if (renderer.xr.isPresenting) {
                const camPos = new THREE.Vector3();
                const camQuat = new THREE.Quaternion();
                camera.getWorldPosition(camPos);
                camera.getWorldQuaternion(camQuat);
                const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camQuat);
                vec.copy(camPos).add(dir.multiplyScalar(0.3)); // 30cm in front
            } else {
                // Sim mode orbit
                const t = Date.now() * 0.001;
                vec.set(Math.sin(t)*0.5, 0, Math.cos(t)*0.5);
            }
            return vec;
        }

    </script>
</body>
</html>


